var documenterSearchIndex = {"docs":
[{"location":"PencilArrays/#PencilArrays_module","page":"Array wrappers","title":"Array wrappers","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"CurrentModule = PencilArrays","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"The PencilArrays module defines types for handling MPI-distributed data.","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"The most important types are:","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"PencilArray: array wrapper including MPI decomposition information. Takes local indices starting at 1, regardless of the location of each MPI process on the global topology.\nGlobalPencilArray: PencilArray wrapper that takes global indices, which generally don't start at 1. See also Global views.","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"PencilArrays","category":"page"},{"location":"PencilArrays/#PencilArrays.PencilArrays","page":"Array wrappers","title":"PencilArrays.PencilArrays","text":"PencilArrays\n\nArray wrappers for MPI-distributed data.\n\n\n\n\n\n","category":"module"},{"location":"PencilArrays/#Construction","page":"Array wrappers","title":"Construction","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"An uninitialised PencilArray can be constructed from a Pencil instance as","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"pencil = Pencil(#= ... =#)\nA = PencilArray{Float64}(undef, pencil)\nparent(A)  # returns the Array wrapped by `A`","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"This allocates a new Array with the local dimensions and data type associated to the Pencil.","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"One can also construct a PencilArray wrapper from an existing AbstractArray, whose dimensions must be compatible with the Pencil configuration. For instance, the following works:","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"dims = size_local(pencil, permute=true)  # dimensions of data array must be permuted!\ndata = zeros(dims)\nA = PencilArray(pencil, data)","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"Note that data does not need to be a Array, but can be any subtype of AbstractArray.","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"It is also possible to construct higher dimensional arrays, as in:","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"data = zeros(dims..., 3, 2)\nA = PencilArray(pencil, data)","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"This will construct a PencilArray where the rightmost dimensions (called extra dimensions in the PencilArrays API) will never be split among MPI processes.","category":"page"},{"location":"PencilArrays/#Dimension-permutations","page":"Array wrappers","title":"Dimension permutations","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"Unlike the wrapped AbstractArray, the PencilArray wrapper takes non-permuted indices. For instance, if the underlying permutation of the Pencil is (2, 3, 1), then A[i, j, k] points to the same value as parent(A)[j, k, i].","category":"page"},{"location":"PencilArrays/#Global-views","page":"Array wrappers","title":"Global views","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"PencilArrays are accessed using local indices that start at 1, regardless of the location of the subdomain associated to the local process on the global grid. Sometimes it may be more convenient to use global indices describing the position of the local process in the domain. For this, the global_view function is provided that generates an OffsetArray wrapper taking global indices.","category":"page"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"For more details, see for instance the gradient example in the PencilFFTs docs.","category":"page"},{"location":"PencilArrays/#Types","page":"Array wrappers","title":"Types","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"PencilArray\nGlobalPencilArray\nPencilArrayCollection\nMaybePencilArrayCollection\nManyPencilArray","category":"page"},{"location":"PencilArrays/#PencilArrays.PencilArray","page":"Array wrappers","title":"PencilArrays.PencilArray","text":"PencilArray(pencil::Pencil, data::AbstractArray{T,N})\n\nCreate array wrapper with pencil decomposition information.\n\nThe array dimensions and element type must be consistent with those of the given pencil.\n\nnote: Index permutations\nIf the Pencil has an associated index permutation, then data must have its dimensions permuted accordingly.Unlike data, the resulting PencilArray should be accessed with unpermuted indices.ExampleSuppose pencil has local dimensions (10, 20, 30) before permutation, and has an asociated permutation (2, 3, 1). Then:data = zeros(20, 30, 10)       # parent array (with permuted dimensions)\n\nu = PencilArray(pencil, data)  # wrapper with dimensions (10, 20, 30)\n@assert size(u) === (10, 20, 30)\n\nu[15, 25, 5]          # BoundsError (15 > 10 and 25 > 20)\nu[5, 15, 25]          # correct\nparent(u)[15, 25, 5]  # correct\n\n\nnote: Extra dimensions\nThe data array can have one or more extra dimensions to the right (slow indices), which are not affected by index permutations.Exampledims = (20, 30, 10)\nPencilArray(pencil, zeros(dims...))        # works (scalar)\nPencilArray(pencil, zeros(dims..., 3))     # works (3-component vector)\nPencilArray(pencil, zeros(dims..., 4, 3))  # works (4×3 tensor)\nPencilArray(pencil, zeros(3, dims...))     # fails\n\n\n\nPencilArray{T}(undef, pencil::Pencil, [extra_dims=()])\n\nAllocate an uninitialised PencilArray that can hold data in the local pencil.\n\nExtra dimensions, for instance representing vector components, can be specified. These dimensions are added to the rightmost (slowest) indices of the resulting array.\n\nExample\n\nSuppose pencil has local dimensions (20, 10, 30) after permutation. Then:\n\nPencilArray{Float64}(undef, pencil)          # array dimensions are (20, 10, 30)\nPencilArray{Float64}(undef, pencil, (4, 3))  # array dimensions are (20, 10, 30, 4, 3)\n\n\n\n\n\n","category":"type"},{"location":"PencilArrays/#PencilArrays.GlobalPencilArray","page":"Array wrappers","title":"PencilArrays.GlobalPencilArray","text":"GlobalPencilArray{T,N} <: AbstractArray{T,N}\n\nAlias for an OffsetArray wrapping a PencilArray.\n\nUnlike PencilArrays, GlobalPencilArrays take global indices, which in general don't start at 1 for a given MPI process.\n\nThe global_view function should be used to create a GlobalPencilArray from a PencilArray.\n\n\n\n\n\n","category":"type"},{"location":"PencilArrays/#PencilArrays.PencilArrayCollection","page":"Array wrappers","title":"PencilArrays.PencilArrayCollection","text":"PencilArrayCollection\n\nUnionAll type describing a collection of PencilArrays.\n\nSuch a collection can be a tuple or an array of PencilArrays.\n\nCollections are by assumption homogeneous: each array has the same properties, and in particular, is associated to the same Pencil configuration.\n\nFor convenience, certain operations defined for PencilArray are also defined for PencilArrayCollection, and return the same value as for a single PencilArray. Some examples are pencil, range_local and get_comm.\n\nAlso note that functions from Base, such as size or ndims, are not overloaded for PencilArrayCollection, since they already have a definition for tuples and arrays (and redefining them would be type piracy...).\n\n\n\n\n\n","category":"constant"},{"location":"PencilArrays/#PencilArrays.MaybePencilArrayCollection","page":"Array wrappers","title":"PencilArrays.MaybePencilArrayCollection","text":"MaybePencilArrayCollection\n\nUnionAll type representing either a PencilArray or a collection of PencilArrays.\n\nSee also PencilArrayCollection.\n\n\n\n\n\n","category":"constant"},{"location":"PencilArrays/#PencilArrays.ManyPencilArray","page":"Array wrappers","title":"PencilArrays.ManyPencilArray","text":"ManyPencilArray{T,N,M}\n\nContainer holding M different PencilArray views to the same underlying data buffer. All views share the same element type T and dimensionality N.\n\nThis can be useful to perform in-place operations on PencilArray data.\n\n\n\nManyPencilArray{T}(undef, pencils...; extra_dims=())\n\nCreate a ManyPencilArray container that can hold data of type T associated to all the given Pencils.\n\nThe optional extra_dims argument is the same as for PencilArray.\n\n\n\n\n\n","category":"type"},{"location":"PencilArrays/#Methods","page":"Array wrappers","title":"Methods","text":"","category":"section"},{"location":"PencilArrays/#PencilArray","page":"Array wrappers","title":"PencilArray","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"extra_dims(::PencilArray)\nget_comm(::MaybePencilArrayCollection)\nget_permutation(::MaybePencilArrayCollection)\nglobal_view(::PencilArray)\nndims_extra(::MaybePencilArrayCollection)\nndims_space(::PencilArray)\nparent(::PencilArray)\npencil(::PencilArray)\npointer(::PencilArray)\nrange_local(::MaybePencilArrayCollection)\nsize(::PencilArray)\nsize_local(::MaybePencilArrayCollection)\nsize_global(::MaybePencilArrayCollection)","category":"page"},{"location":"PencilArrays/#PencilArrays.extra_dims-Tuple{PencilArray}","page":"Array wrappers","title":"PencilArrays.extra_dims","text":"extra_dims(x::PencilArray)\nextra_dims(x::PencilArrayCollection)\n\nReturn tuple with size of \"extra\" dimensions of PencilArray.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.Pencils.MPITopologies.get_comm-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.Pencils.MPITopologies.get_comm","text":"get_comm(x::PencilArray)\nget_comm(x::PencilArrayCollection)\n\nGet MPI communicator associated to a pencil-distributed array.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.Pencils.get_permutation-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.Pencils.get_permutation","text":"get_permutation(x::PencilArray)\nget_permutation(x::PencilArrayCollection)\n\nGet index permutation associated to the given PencilArray.\n\nReturns NoPermutation() if there is no associated permutation.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.global_view-Tuple{PencilArray}","page":"Array wrappers","title":"PencilArrays.global_view","text":"global_view(x::PencilArray)\n\nCreate an OffsetArray of a PencilArray that takes unpermuted global indices.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.ndims_extra-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.ndims_extra","text":"ndims_extra(x::PencilArray)\nndims_extra(x::PencilArrayCollection)\n\nNumber of \"extra\" dimensions associated to PencilArray.\n\nThese are the dimensions that are not associated to the domain geometry. For instance, they may correspond to vector or tensor components.\n\nThese dimensions correspond to the rightmost indices of the array.\n\nThe total number of dimensions of a PencilArray is given by:\n\nndims(x) == ndims_space(x) + ndims_extra(x)\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.ndims_space-Tuple{PencilArray}","page":"Array wrappers","title":"PencilArrays.ndims_space","text":"ndims_space(x::PencilArray)\nndims_space(x::PencilArrayCollection)\n\nNumber of dimensions associated to the domain geometry.\n\nThese dimensions correspond to the leftmost indices of the array.\n\nThe total number of dimensions of a PencilArray is given by:\n\nndims(x) == ndims_space(x) + ndims_extra(x)\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.parent-Tuple{PencilArray}","page":"Array wrappers","title":"Base.parent","text":"parent(x::PencilArray)\n\nReturn array wrapped by a PencilArray.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.pencil-Tuple{PencilArray}","page":"Array wrappers","title":"PencilArrays.pencil","text":"pencil(x::PencilArray)\n\nReturn decomposition configuration associated to a PencilArray.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.pointer-Tuple{PencilArray}","page":"Array wrappers","title":"Base.pointer","text":"pointer(x::PencilArray)\n\nReturn pointer to the start of the underlying data.\n\nUse with caution: this may not make a lot of sense if the underlying data is not contiguous or strided (e.g. if the PencilArray is wrapping a non-strided SubArray).\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.Pencils.range_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.Pencils.range_local","text":"range_local(x::PencilArray; permute=false)\nrange_local(x::PencilArrayCollection; permute=false)\n\nLocal data range held by the PencilArray.\n\nBy default the dimensions are not permuted, i.e. they are returned in logical order.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.size-Tuple{PencilArray}","page":"Array wrappers","title":"Base.size","text":"size(x::PencilArray)\n\nReturn logical (unpermuted) local dimensions of a PencilArray.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.Pencils.size_local-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.Pencils.size_local","text":"size_local(x::PencilArray; permute=false)\nsize_local(x::PencilArrayCollection; permute=false)\n\nLocal dimensions of the data held by the PencilArray.\n\nIf permute=false, this is the same as size(x).\n\nSee also size_local(::Pencil).\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#PencilArrays.Pencils.size_global-Tuple{Union{PencilArray, Union{Tuple{Vararg{A,N} where N}, AbstractArray{A,N} where N} where A<:PencilArray}}","page":"Array wrappers","title":"PencilArrays.Pencils.size_global","text":"size_global(x::PencilArray; permute=false)\nsize_global(x::PencilArrayCollection; permute=false)\n\nGlobal dimensions associated to the given array.\n\nBy default, the logical (unpermuted) dimensions of the dataset are returned.\n\nSee also size_global(::Pencil).\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#ManyPencilArray","page":"Array wrappers","title":"ManyPencilArray","text":"","category":"section"},{"location":"PencilArrays/","page":"Array wrappers","title":"Array wrappers","text":"first(::ManyPencilArray)\ngetindex(::ManyPencilArray)\nlast(::ManyPencilArray)\nlength(::ManyPencilArray)","category":"page"},{"location":"PencilArrays/#Base.first-Tuple{ManyPencilArray}","page":"Array wrappers","title":"Base.first","text":"first(A::ManyPencilArray)\n\nReturns the first PencilArray wrapped by A.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.getindex-Tuple{ManyPencilArray}","page":"Array wrappers","title":"Base.getindex","text":"getindex(A::ManyPencilArray, ::Val{i})\ngetindex(A::ManyPencilArray, i::Integer)\n\nReturns the i-th PencilArray wrapped by A.\n\nIf possible, the Val{i} form should be preferred, as it is more efficient and it allows the compiler to know the return type.\n\nSee also first(::ManyPencilArray), last(::ManyPencilArray).\n\nExample\n\nA = ManyPencilArray(pencil1, pencil2, pencil3)\n\n# Get the PencilArray associated to `pencil2`.\n# u2 = A[2]\nu2 = A[Val(2)]  # faster!\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.last-Tuple{ManyPencilArray}","page":"Array wrappers","title":"Base.last","text":"last(A::ManyPencilArray)\n\nReturns the last PencilArray wrapped by A.\n\n\n\n\n\n","category":"method"},{"location":"PencilArrays/#Base.length-Tuple{ManyPencilArray}","page":"Array wrappers","title":"Base.length","text":"length(A::ManyPencilArray)\n\nReturns the number of PencilArrays wrapped by A.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#sec:pencil_configs","page":"Pencil configurations","title":"Pencil configurations","text":"","category":"section"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"A pencil configuration refers to a given distribution of multidimensional data among MPI processes. This information is encoded in the Pencil type.","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"A pencil configuration includes:","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"MPI topology information,\nglobal and local dimensions of the numerical grid,\nsubset of decomposed dimensions,\ntype of decomposed data (e.g. Float64),\ndefinition of optional permutation of dimensions.","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"Pencils","category":"page"},{"location":"Pencils/#PencilArrays.Pencils","page":"Pencil configurations","title":"PencilArrays.Pencils","text":"Pencils\n\nBase module defining types for multidimensional data decompositions using MPI.\n\n\n\n\n\n","category":"module"},{"location":"Pencils/#Construction","page":"Pencil configurations","title":"Construction","text":"","category":"section"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"The creation of a new Pencil requires a MPITopology, as well as the global data dimensions and a list of decomposed dimensions. Optionally, one can also specify the data type (the default is Float64) and a permutation of dimensions.","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"For instance, to decompose along the first and third dimensions of a complex 3D dataset,","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"topology = MPITopology(#= ... =#)\ndims_global = (16, 32, 64)\ndecomp_dims = (1, 3)  # this requires ndims(topology) == 2\npencil = Pencil(topology, dims_global, decomp_dims, Complex{Float64})","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"One may also want to create multiple pencil configurations that differ, for instance, on the selection of decomposed dimensions. For this case, a second constructor is available that takes an already existing Pencil instance. Calling this constructor should be preferred when possible since it allows sharing memory buffers (used for instance for global transpositions) and thus reducing memory usage. The following creates a Pencil equivalent to the one above, but with different decomposed dimensions:","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"pencil_x = Pencil(pencil, decomp_dims=(2, 3))","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"See the Pencil documentation for more details.","category":"page"},{"location":"Pencils/#Dimension-permutations","page":"Pencil configurations","title":"Dimension permutations","text":"","category":"section"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"As mentioned above, a Pencil may optionally be given information on dimension permutations. In this case, the layout of the data arrays in memory is different from the logical order of dimensions.","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"To make this clearer, consider the example above where the global data dimensions are N_x  N_y  N_z = 16  32  64. In this case, the logical order is (x y z). Now let's say that we want the memory order of the data to be (y z x),[1] which corresponds to the permutation (2, 3, 1).","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"Permutations are passed to the Pencil constructor via the permute keyword argument. For performance reasons, dimension permutations are compile-time constants, and they should be specified using the Permutation type defined in PencilArrays. For instance,","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"permutation = Permutation(2, 3, 1)\npencil = Pencil(#= ... =#, permute=permutation)","category":"page"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"One can also pass NoPermutation as a permutation, which disables permutations (this is the default).","category":"page"},{"location":"Pencils/#Types","page":"Pencil configurations","title":"Types","text":"","category":"section"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"Pencil\nPermutation\nNoPermutation","category":"page"},{"location":"Pencils/#PencilArrays.Pencils.Pencil","page":"Pencil configurations","title":"PencilArrays.Pencils.Pencil","text":"Pencil{N,M}\n\nDescribes the decomposition of an N-dimensional array among MPI processes along M directions (with M < N).\n\n\n\nPencil(\n    topology::MPITopology{M}, size_global::Dims{N}, decomp_dims::Dims{M};\n    permute::Permutation = NoPermutation(),\n    timer = TimerOutput(),\n)\n\nDefine the decomposition of an N-dimensional geometry along M dimensions.\n\nThe dimensions of the geometry are given by size_global = (N1, N2, ...). The Pencil describes the decomposition of an array of dimensions size_global across a group of MPI processes.\n\nData is distributed over the given M-dimensional MPI topology (with M < N). The decomposed dimensions are given by decomp_dims.\n\nThe optional parameter perm should be a (compile-time) tuple defining a permutation of the data indices. Such permutation may be useful for performance reasons, since it may be preferable (e.g. for FFTs) that the data is contiguous along the pencil direction.\n\nIt is also possible to pass a TimerOutput to the constructor. See Measuring performance for details.\n\nExamples\n\nDecompose a 3D geometry of global dimensions N_x  N_y  N_z = 4812 along the second (y) and third (z) dimensions.\n\nPencil(topology, (4, 8, 12), (2, 3))                                # data is in (x, y, z) order\nPencil(topology, (4, 8, 12), (2, 3), permute=Permutation(3, 2, 1))  # data is in (z, y, x) order\n\nIn the second case, the actual data is stored in (z, y, x) order within each MPI process.\n\n\n\nPencil(\n    p::Pencil{N,M};\n    decomp_dims::Dims{M} = get_decomposition(p),\n    size_global::Dims{N} = size_global(p),\n    permute::P = get_permutation(p),\n    timer::TimerOutput = get_timer(p),\n)\n\nCreate new pencil configuration from an existent one.\n\nThis constructor enables sharing temporary data buffers between the two pencil configurations, leading to reduced global memory usage.\n\n\n\n\n\n","category":"type"},{"location":"Pencils/#PencilArrays.Permutations.Permutation","page":"Pencil configurations","title":"PencilArrays.Permutations.Permutation","text":"Permutation{p}\n\nDescribes a compile-time dimension permutation.\n\nThe type parameter p should be a valid permutation such as (3, 1, 2).\n\nThe parameter p may also be nothing. A Permutation{nothing} represents an identity permutation: it is equivalent to Permutation{(1, 2, …, N)} for any number of dimensions N. The NoPermutation type is provided as an alias for Permutation{nothing}.\n\n\n\nPermutation(perm::Vararg{Int})\nPermutation(perm::NTuple{N,Int})\n\nConstructs a Permutation.\n\nExample\n\nBoth are equivalent:\n\np1 = Permutation(3, 4)\np2 = Permutation((3, 4))\n\n\n\nPermutation(nothing)\nNoPermutation()\n\nConstructs an identity permutation.\n\n\n\n\n\n","category":"type"},{"location":"Pencils/#PencilArrays.Permutations.NoPermutation","page":"Pencil configurations","title":"PencilArrays.Permutations.NoPermutation","text":"NoPermutation\n\nAlias for an identity permutation, i.e. NoPermutation = Permutation{nothing}.\n\nThis alias can be called as a constructor: NoPermutation() creates a Permutation{nothing}, as expected.\n\n\n\n\n\n","category":"type"},{"location":"Pencils/#Methods","page":"Pencil configurations","title":"Methods","text":"","category":"section"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"get_comm(::Pencil)\nget_decomposition(::Pencil)\nget_permutation(::Pencil)\nget_timer(::Pencil)\nlength(::Pencil)\nndims(::Pencil)\nrange_local(::Pencil{N}) where N\nsize_global(::Pencil)\nsize_local(::Pencil)\nto_local(::Pencil)","category":"page"},{"location":"Pencils/#PencilArrays.Pencils.MPITopologies.get_comm-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.MPITopologies.get_comm","text":"get_comm(p::Pencil)\n\nGet MPI communicator associated to an MPI decomposition scheme.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.get_decomposition-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.get_decomposition","text":"get_decomposition(p::Pencil)\n\nGet tuple with decomposed dimensions of the given pencil configuration.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.get_permutation-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.get_permutation","text":"get_permutation(p::Pencil)\n\nGet index permutation associated to the given pencil configuration.\n\nReturns NoPermutation() if there is no associated permutation.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.get_timer-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.get_timer","text":"get_timer(p::Pencil)\n\nGet TimerOutput attached to a Pencil.\n\nSee Measuring performance for details.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#Base.length-Tuple{Pencil}","page":"Pencil configurations","title":"Base.length","text":"length(p::Pencil)\n\nGet linear length of data associated to the local pencil layout.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#Base.ndims-Tuple{Pencil}","page":"Pencil configurations","title":"Base.ndims","text":"ndims(t::MPITopology)\n\nGet dimensionality of Cartesian topology.\n\n\n\n\n\nndims(p::Pencil)\n\nNumber of spatial dimensions associated to pencil data.\n\nThis corresponds to the total number of dimensions of the space, which includes the decomposed and non-decomposed dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.range_local-Union{Tuple{Pencil{N,M,T,P} where P where T<:Number where M}, Tuple{N}} where N","page":"Pencil configurations","title":"PencilArrays.Pencils.range_local","text":"range_local(p::Pencil; permute=false)\n\nLocal data range held by the pencil.\n\nBy default the dimensions are not permuted, i.e. they follow the logical order of dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.size_global-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.size_global","text":"size_global(p::Pencil; permute=false)\n\nGlobal dimensions of the Cartesian grid associated to the given domain decomposition.\n\nLike size_local, by default the returned dimensions are not permuted.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.size_local-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.size_local","text":"size_local(p::Pencil; permute=false)\n\nLocal dimensions of the data held by the pencil.\n\nBy default the dimensions are not permuted, i.e. they follow the logical order of dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/#PencilArrays.Pencils.to_local-Tuple{Pencil}","page":"Pencil configurations","title":"PencilArrays.Pencils.to_local","text":"to_local(p::Pencil, global_inds; permute=false)\n\nConvert non-permuted global indices to local indices.\n\nIndices can be optionally permuted using the permutation associated to the pencil configuration p.\n\n\n\n\n\n","category":"method"},{"location":"Pencils/","page":"Pencil configurations","title":"Pencil configurations","text":"[1]: Why would we want this? Perhaps because we want to efficiently perform FFTs along y, which, under this permutation, would be the fastest dimension. This is used by the PencilFFTs package.","category":"page"},{"location":"MPITopology/#sec:mpi_topology","page":"MPI topology","title":"MPI topology","text":"","category":"section"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"The MPITopology type defines the MPI Cartesian topology of the decomposition. In other words, it contains information about the number of decomposed dimensions, and the number of processes in each of these dimensions.","category":"page"},{"location":"MPITopology/#Construction","page":"MPI topology","title":"Construction","text":"","category":"section"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"The main MPITopology constructor takes a MPI communicator and a tuple specifying the number of processes in each dimension. For instance, to distribute 12 MPI processes on a 3  4 grid:","category":"page"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"comm = MPI.COMM_WORLD  # we assume MPI.Comm_size(comm) == 12\npdims = (3, 4)\ntopology = MPITopology(comm, pdims)","category":"page"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"At the lower level, MPITopology uses MPI_Cart_create to define a Cartesian MPI communicator. For more control, one can also create a Cartesian communicator using MPI.Cart_create, and pass that to MPITopology:","category":"page"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"comm = MPI.COMM_WORLD\ndims = [3, 4]  # note: array, not tuple!\nperiods = zeros(Int, N)\nreorder = false\ncomm_cart = MPI.Cart_create(comm, dims, periods, reorder)\ntopology = MPITopology(comm_cart)","category":"page"},{"location":"MPITopology/#Types","page":"MPI topology","title":"Types","text":"","category":"section"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"MPITopology","category":"page"},{"location":"MPITopology/#PencilArrays.Pencils.MPITopologies.MPITopology","page":"MPI topology","title":"PencilArrays.Pencils.MPITopologies.MPITopology","text":"MPITopology{N}\n\nDescribes an N-dimensional Cartesian MPI decomposition topology.\n\n\n\nMPITopology(comm::MPI.Comm, pdims::Dims{N}) where N\n\nCreate N-dimensional MPI topology information.\n\nThe pdims tuple specifies the number of MPI processes to put in every dimension of the topology. The product of its values must be equal to the number of processes in communicator comm.\n\nExample\n\n# Divide 2D topology into 4×2 blocks.\ncomm = MPI.COMM_WORLD\n@assert MPI.Comm_size(comm) == 8\ntopology = MPITopology(comm, (4, 2))\n\n\n\nMPITopology{N}(comm_cart::MPI.Comm) where N\n\nCreate topology information from MPI communicator with Cartesian topology (typically constructed using MPI.Cart_create). The topology must have dimension N.\n\n\n\n\n\n","category":"type"},{"location":"MPITopology/#Methods","page":"MPI topology","title":"Methods","text":"","category":"section"},{"location":"MPITopology/","page":"MPI topology","title":"MPI topology","text":"get_comm(::MPITopology)\nlength(::MPITopology)\nndims(::MPITopology)\nsize(::MPITopology)","category":"page"},{"location":"MPITopology/#PencilArrays.Pencils.MPITopologies.get_comm-Tuple{MPITopology}","page":"MPI topology","title":"PencilArrays.Pencils.MPITopologies.get_comm","text":"get_comm(t::MPITopology)\n\nGet MPI communicator associated to an MPI Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"MPITopology/#Base.length-Tuple{MPITopology}","page":"MPI topology","title":"Base.length","text":"length(t::MPITopology)\n\nGet total size of Cartesian topology (i.e. total number of MPI processes).\n\n\n\n\n\n","category":"method"},{"location":"MPITopology/#Base.ndims-Tuple{MPITopology}","page":"MPI topology","title":"Base.ndims","text":"ndims(t::MPITopology)\n\nGet dimensionality of Cartesian topology.\n\n\n\n\n\nndims(p::Pencil)\n\nNumber of spatial dimensions associated to pencil data.\n\nThis corresponds to the total number of dimensions of the space, which includes the decomposed and non-decomposed dimensions.\n\n\n\n\n\n","category":"method"},{"location":"MPITopology/#Base.size-Tuple{MPITopology}","page":"MPI topology","title":"Base.size","text":"size(t::MPITopology)\n\nGet dimensions of Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"PencilIO/#PencilIO_module","page":"Parallel I/O","title":"Parallel I/O","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"CurrentModule = PencilArrays.PencilIO","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"The PencilArrays.PencilIO module contains functions for saving and loading PencilArrays to disk using MPI-IO. Parallel I/O is performed using Parallel HDF5 through the HDF5.jl package.","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"The implemented approach consists in storing the data coming from different MPI processes in a single file. This strategy scales better in terms of number of files, and is more convenient, than that of storing one file per process. However, the performance is very sensitive to the configuration of the underlying file system. In distributed file systems such as Lustre, it is worth tuning parameters such as the stripe count and stripe size (see for instance the Parallel HDF5 page for more information).","category":"page"},{"location":"PencilIO/#setting_up_parallel_hdf5","page":"Parallel I/O","title":"Setting-up Parallel HDF5","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"Parallel HDF5 is not enabled in the default installation of HDF5.jl. For Parallel HDF5 to work, the HDF5 C libraries wrapped by HDF5.jl must be compiled with parallel support and linked to the specific MPI implementation that will be used for parallel I/O. HDF5.jl must be explicitly instructed to use parallel-enabled HDF5 libraries available in the system. Similarly, MPI.jl must be instructed to use the corresponding MPI libraries. This is detailed in the sections below.","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"Parallel-enabled HDF5 libraries are usually included in computing clusters and linked to the available MPI implementations. They are also available via the package manager of a number of Linux distributions. (For instance, Fedora includes the hdf5-mpich-devel and hdf5-openmpi-devel packages, respectively linked to the MPICH and OpenMPI libraries in the Fedora repositories.)","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"The following step-by-step guide assumes one already has access to parallel-enabled HDF5 libraries linked to an existent MPI installation.","category":"page"},{"location":"PencilIO/#.-Using-system-provided-MPI-libraries","page":"Parallel I/O","title":"1. Using system-provided MPI libraries","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"Set the environment variable JULIA_MPI_BINARY=system and then run ]build MPI from Julia. For more control, one can also set the JULIA_MPI_PATH environment variable to the top-level installation directory of the MPI library.","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"See the MPI.jl docs for details.","category":"page"},{"location":"PencilIO/#.-Using-parallel-HDF5-libraries","page":"Parallel I/O","title":"2. Using parallel HDF5 libraries","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"Set the JULIA_HDF5_LIBRARY_PATH environment variable to the directory where the HDF5 libraries compiled with parallel support are found. Then run ]build HDF5 from Julia. Note that the selected HDF5 library must be linked to the MPI library chosen in the previous section. For the set-up to be persistent across HDF5.jl updates, consider setting JULIA_HDF5_LIBRARY_PATH in ~/.bashrc or similar.","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"See the HDF5.jl README for details.","category":"page"},{"location":"PencilIO/#.-Loading-PencilIO","page":"Parallel I/O","title":"3. Loading PencilIO","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"In the PencilIO module, the HDF5.jl package is lazy-loaded using Requires. This means that, in Julia code, PencilArrays must be loaded after HDF5 for parallel I/O functionality to be available.","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"The following order of usings ensures that parallel I/O support is available:","category":"page"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"using MPI\nusing HDF5\nusing PencilArrays","category":"page"},{"location":"PencilIO/#Library","page":"Parallel I/O","title":"Library","text":"","category":"section"},{"location":"PencilIO/","page":"Parallel I/O","title":"Parallel I/O","text":"ph5open\nsetindex!\nread!\nhdf5_has_parallel","category":"page"},{"location":"PencilIO/#PencilArrays.PencilIO.ph5open","page":"Parallel I/O","title":"PencilArrays.PencilIO.ph5open","text":"ph5open([f::Function], filename, [mode=\"r\"], comm::MPI.Comm,\n        [info::MPI.Info=MPI.Info()], prop_lists...) -> HDF5.File\n\nOpen parallel HDF5 file.\n\nThis function is a thin wrapper over HDF5.h5open. It converts MPI.jl types (MPI.Comm and MPI.Info) to their counterparts in HDF5.jl. It also throws an informative error if the loaded HDF5 libraries do not include parallel support.\n\nProperty lists\n\nThis function automatically sets the fapl_mpio file access property list to the given MPI communicator and info object. Other property lists should be given as name-value pairs, following the h5open syntax.\n\nProperty lists are passed to h5f_create. The following property types are recognised:\n\nfile creation properties,\nfile access properties.\n\n\n\n\n\n","category":"function"},{"location":"PencilIO/#Base.setindex!","page":"Parallel I/O","title":"Base.setindex!","text":"setindex!(g::Union{HDF5File,HDF5Group}, x::MaybePencilArrayCollection,\n          name::String, prop_lists...; chunks=false, collective=true)\n\nWrite PencilArray or PencilArrayCollection to parallel HDF5 file.\n\nFor performance reasons, the memory layout of the data is conserved. In other words, if the dimensions of a PencilArray are permuted in memory, then the data is written in permuted form.\n\nIn the case of a PencilArrayCollection, each array of the collection is written as a single component of a higher-dimension dataset.\n\nOptional arguments\n\nif chunks=true, data is written in chunks, with roughly one chunk per MPI process. This may (or may not) improve performance in parallel filesystems.\nif collective=true, the dataset is written collectivelly. This is usually recommended for performance.\nadditional property lists may be specified by name-value pairs in prop_lists, following the HDF5.jl syntax. These property lists take precedence over keyword arguments. For instance, if the \"dxpl_mpio\", HDF5.H5FD_MPIO_COLLECTIVE pair is passed, then the value of the collective argument is ignored.\n\nProperty lists\n\nProperty lists are passed to h5d_create and h5d_write. The following property types are recognised:\n\nlink creation properties,\ndataset creation properties,\ndataset access properties,\ndataset transfer properties.\n\nExample\n\nOpen a parallel HDF5 file and write some PencilArrays to the file:\n\npencil = Pencil(#= ... =#)\nu = PencilArray{Float64}(undef, pencil)\nv = similar(u)\n\n# [fill the arrays with interesting values...]\n\ncomm = get_comm(u)\ninfo = MPI.Info()\n\nph5open(\"filename.h5\", \"w\", comm, info) do ff\n    ff[\"u\", chunks=true] = u\n    ff[\"uv\"] = (u, v)  # this is a two-component PencilArrayCollection (assuming equal dimensions of `u` and `v`)\nend\n\n\n\n\n\n","category":"function"},{"location":"PencilIO/#Base.read!","page":"Parallel I/O","title":"Base.read!","text":"read!(g::Union{HDF5File,HDF5Group}, x::MaybePencilArrayCollection,\n      name::String, prop_lists...; collective=true)\n\nRead PencilArray or PencilArrayCollection from parallel HDF5 file.\n\nSee setindex! for details on optional arguments.\n\nProperty lists\n\nProperty lists are passed to h5d_open and h5d_read. The following property types are recognised:\n\ndataset access properties,\ndataset transfer properties.\n\nExample\n\nOpen a parallel HDF5 file and read some PencilArrays:\n\npencil = Pencil(#= ... =#)\nu = PencilArray{Float64}(undef, pencil)\nv = similar(u)\n\ncomm = get_comm(u)\ninfo = MPI.Info()\n\nph5open(\"filename.h5\", \"r\", comm, info) do ff\n    read!(ff, u, \"u\")\n    read!(ff, (u, v), \"uv\")\nend\n\n\n\n\n\n","category":"function"},{"location":"PencilIO/#PencilArrays.PencilIO.hdf5_has_parallel","page":"Parallel I/O","title":"PencilArrays.PencilIO.hdf5_has_parallel","text":"hdf5_has_parallel() -> Bool\n\nReturns true if the loaded HDF5 libraries support MPI-IO.\n\n\n\n\n\n","category":"function"},{"location":"Transpositions/#Global-MPI-operations","page":"Global MPI operations","title":"Global MPI operations","text":"","category":"section"},{"location":"Transpositions/","page":"Global MPI operations","title":"Global MPI operations","text":"CurrentModule = PencilArrays","category":"page"},{"location":"Transpositions/","page":"Global MPI operations","title":"Global MPI operations","text":"One of the most time-consuming parts of a large-scale computation involving multidimensional FFTs, is the global data transpositions between different MPI decomposition configurations. In PencilArrays, this is performed by the transpose! function, which takes two PencilArrays, typically associated to two different configurations. The implementation performs comparably to similar implementations in lower-level languages (see PencilFFTs benchmarks for details).","category":"page"},{"location":"Transpositions/","page":"Global MPI operations","title":"Global MPI operations","text":"Also provided is a gather function that creates a single global array from decomposed data. This can be useful for tests (in fact, it is used in the PencilArrays tests to verify the correctness of the transpositions), but shouldn't be used with large datasets. It is generally useful for small problems where the global size of the data can easily fit the locally available memory.","category":"page"},{"location":"Transpositions/","page":"Global MPI operations","title":"Global MPI operations","text":"Transpositions.Transposition\nTranspositions.transpose!\nMPI.Waitall!\ngather","category":"page"},{"location":"Transpositions/#PencilArrays.Transpositions.Transposition","page":"Global MPI operations","title":"PencilArrays.Transpositions.Transposition","text":"Transposition\n\nHolds data for transposition between two pencil configurations.\n\n\n\nTransposition(dest::PencilArray{T,N}, src::PencilArray{T,N};\n              method=Transpositions.IsendIrecv())\n\nPrepare transposition of arrays from one pencil configuration to the other.\n\nThe two pencil configurations must be compatible for transposition:\n\nthey must share the same MPI Cartesian topology,\nthey must have the same global data size,\nwhen written as a sorted tuple, the decomposed dimensions must be almost the same, with at most one difference. For instance, if the input of a 3D dataset is decomposed in (2, 3), then the output may be decomposed in (1, 3), but not in (1, 2). If the decomposed dimensions are the same, then no transposition is performed, and data is just copied if needed.\n\nThe src and dest arrays may be aliased (they can share memory space).\n\nPerformance tuning\n\nThe method argument allows to choose between transposition implementations. This can be useful to tune performance of MPI data transfers. Two values are currently accepted:\n\nTranspositions.IsendIrecv() uses non-blocking point-to-point data transfers (MPI_Isend and MPI_Irecv). This may be more performant since data transfers are interleaved with local data transpositions (index permutation of received data). This is the default.\nTranspositions.Alltoallv() uses MPI_Alltoallv for global data transpositions.\n\n\n\n\n\n","category":"type"},{"location":"Transpositions/#LinearAlgebra.transpose!","page":"Global MPI operations","title":"LinearAlgebra.transpose!","text":"transpose!(t::Transposition; waitall=true)\ntranspose!(dest::PencilArray{T,N}, src::PencilArray{T,N};\n           method=Transpositions.IsendIrecv())\n\nTranspose data from one pencil configuration to the other.\n\nThe first variant allows to optionally delay the wait for MPI send operations to complete. This is useful if the caller wants to perform other operations with the already received data. To do this, the caller should pass waitall=false, and manually invoke MPI.Waitall! on the Transposition object once the operations are done. Note that this option only has an effect when the transposition method is IsendIrecv.\n\nSee Transposition for details.\n\n\n\n\n\n","category":"function"},{"location":"Transpositions/#MPI.Waitall!","page":"Global MPI operations","title":"MPI.Waitall!","text":"MPI.Waitall!(t::Transposition)\n\nWait for completion of all unfinished MPI communications related to the transposition.\n\n\n\n\n\n","category":"function"},{"location":"Transpositions/#PencilArrays.gather","page":"Global MPI operations","title":"PencilArrays.gather","text":"gather(x::PencilArray, [root::Integer=0])\n\nGather data from all MPI processes into one (big) array.\n\nData is received by the root process.\n\nReturns the full array on the root process, and nothing on the other processes.\n\nThis can be useful for testing, but it shouldn't be used with very large datasets!\n\n\n\n\n\n","category":"function"},{"location":"PencilArrays_timers/#PencilArrays.measuring_performance","page":"Measuring performance","title":"Measuring performance","text":"","category":"section"},{"location":"PencilArrays_timers/","page":"Measuring performance","title":"Measuring performance","text":"It is possible to measure the time spent in different sections of the MPI data transposition routines using the TimerOutputs package. This has a (very small) performance overhead, so it is disabled by default. To enable time measurements, call TimerOutputs.enable_debug_timings after loading PencilArrays (see below for an example). For more details see the TimerOutputs docs.","category":"page"},{"location":"PencilArrays_timers/","page":"Measuring performance","title":"Measuring performance","text":"Minimal example:","category":"page"},{"location":"PencilArrays_timers/","page":"Measuring performance","title":"Measuring performance","text":"using MPI\nusing PencilArrays\nusing TimerOutputs\n\n# Enable timing of `PencilArrays` functions\nTimerOutputs.enable_debug_timings(PencilArrays)\nTimerOutputs.enable_debug_timings(Transpositions)\n\nMPI.Init()\n\npencil = Pencil(#= args... =#)\n\n# [do stuff with `pencil`...]\n\n# Retrieve and print timing data associated to `plan`\nto = get_timer(pencil)\nprint_timer(to)","category":"page"},{"location":"PencilArrays_timers/","page":"Measuring performance","title":"Measuring performance","text":"By default, each Pencil has its own TimerOutput. If you already have a TimerOutput, you can pass it to the Pencil constructor:","category":"page"},{"location":"PencilArrays_timers/","page":"Measuring performance","title":"Measuring performance","text":"to = TimerOutput()\npencil = Pencil(..., timer=to)\n\n# [do stuff with `pencil`...]\n\nprint_timer(to)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PencilArrays","category":"page"},{"location":"#PencilArrays","page":"Home","title":"PencilArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Distributed Julia arrays using the MPI protocol.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a convenient framework for working with multidimensional Julia arrays distributed among MPI processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The name of this package originates from the decomposition of 3D domains along two out of three dimensions, sometimes called pencil decomposition. This is illustrated by the figure below,[1] where each coloured block is managed by a different MPI process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"figure\">\n  <img\n    width=\"85%\"\n    src=\"img/pencils.svg\"\n    alt=\"Pencil decomposition of 3D domains\">\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"More generally, PencilArrays can decompose arrays of arbitrary dimension N, along an arbitrary subset of M dimensions. (In the example above, N = 3 and M = 2.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PencilArrays is the basis for the PencilFFTs package, which provides efficient and highly scalable distributed FFTs.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"distribution of N-dimensional arrays among MPI processes;\ndecomposition of arrays along an arbitrary subset of dimensions;\ntranspositions between different decomposition configurations, using point-to-point and collective MPI communications;\nzero-cost, arbitrary dimension permutations à la PermutedDimsArray;\nconvenient parallel I/O using the Parallel HDF5 libraries;\ndistributed FFTs and related transforms via the PencilFFTs package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PencilArrays will soon be registered as a Julia package. Then, it will be installable using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add PencilArrays","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Figure adapted from this PhD thesis.","category":"page"},{"location":"PermutationUtils/#Permutation-tools","page":"Permutation tools","title":"Permutation tools","text":"","category":"section"},{"location":"PermutationUtils/","page":"Permutation tools","title":"Permutation tools","text":"Tools for working with Permutation objects.","category":"page"},{"location":"PermutationUtils/","page":"Permutation tools","title":"Permutation tools","text":"CurrentModule = PencilArrays.Permutations","category":"page"},{"location":"PermutationUtils/","page":"Permutation tools","title":"Permutation tools","text":"append_to_permutation\ncheck_permutation\ninverse_permutation\nis_identity_permutation\npermute_indices\nrelative_permutation","category":"page"},{"location":"PermutationUtils/#PencilArrays.Permutations.append_to_permutation","page":"Permutation tools","title":"PencilArrays.Permutations.append_to_permutation","text":"append_to_permutation(p::Permutation, ::Val{M})\n\nAppend M non-permuted dimensions to the given permutation.\n\nExamples\n\njulia> append_to_permutation(Permutation(2, 3, 1), Val(2))\nPermutation(2, 3, 1, 4, 5)\n\njulia> append_to_permutation(NoPermutation(), Val(2))\nNoPermutation()\n\n\n\n\n\n","category":"function"},{"location":"PermutationUtils/#PencilArrays.Permutations.check_permutation","page":"Permutation tools","title":"PencilArrays.Permutations.check_permutation","text":"check_permutation(perm)\n\nCheck the validity of a Permutation.\n\nThrows ArgumentError if the permutation is invalid.\n\nExamples\n\njulia> check_permutation(Permutation(3, 2, 1))  # no error\n\njulia> check_permutation(NoPermutation())       # no error\n\njulia> check_permutation(Permutation(3, 3, 1))\nERROR: ArgumentError: invalid permutation of dimensions: Permutation(3, 3, 1)\n\n\n\n\n\n","category":"function"},{"location":"PermutationUtils/#PencilArrays.Permutations.inverse_permutation","page":"Permutation tools","title":"PencilArrays.Permutations.inverse_permutation","text":"inverse_permutation(p::Permutation)\n\nReturns the inverse permutation of p.\n\nFunctionally equivalent to Julia's invperm, with the advantage that the result is a compile time constant.\n\nSee also relative_permutation.\n\nExamples\n\njulia> p = Permutation(2, 3, 1);\n\njulia> q = inverse_permutation(p)\nPermutation(3, 1, 2)\n\njulia> t_orig = (36, 42, 14);\n\njulia> t_perm = permute_indices(t_orig, p)\n(42, 14, 36)\n\njulia> permute_indices(t_perm, q) === t_orig\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"PermutationUtils/#PencilArrays.Permutations.is_identity_permutation","page":"Permutation tools","title":"PencilArrays.Permutations.is_identity_permutation","text":"is_identity_permutation(p::Permutation)\n\nReturns true if p is an identity permutation, i.e. if it is equivalent to (1, 2, 3, ...).\n\njulia> is_identity_permutation(Permutation(1, 2, 3))\ntrue\n\njulia> is_identity_permutation(Permutation(1, 3, 2))\nfalse\n\njulia> is_identity_permutation(NoPermutation())\ntrue\n\n\n\n\n\n","category":"function"},{"location":"PermutationUtils/#PencilArrays.Permutations.permute_indices","page":"Permutation tools","title":"PencilArrays.Permutations.permute_indices","text":"permute_indices(indices, perm::Permutation)\n\nPermute indices according to a compile-time permutation.\n\nindices may be a Tuple of indices, a CartesianIndex, or a Permutation to be reordered according to perm.\n\nExamples\n\njulia> perm = Permutation(2, 3, 1);\n\njulia> permute_indices((36, 42, 14), perm)\n(42, 14, 36)\n\njulia> permute_indices(CartesianIndex(36, 42, 14), perm)\nCartesianIndex(42, 14, 36)\n\njulia> permute_indices(Permutation(3, 1, 2), perm)\nPermutation(1, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"PermutationUtils/#PencilArrays.Permutations.relative_permutation","page":"Permutation tools","title":"PencilArrays.Permutations.relative_permutation","text":"relative_permutation(x::Permutation, y::Permutation)\n\nGet relative permutation needed to get from x to y. That is, the permutation perm such that permute_indices(x, perm) == y.\n\nThe computation is performed at compile time using generated functions.\n\nExamples\n\njulia> x = Permutation(3, 1, 2);\n\njulia> y = Permutation(2, 1, 3);\n\njulia> perm = relative_permutation(x, y)\nPermutation(3, 2, 1)\n\njulia> permute_indices(x, perm) == y\ntrue\n\n\n\n\n\n","category":"function"}]
}
